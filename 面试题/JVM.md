### 1、JVM内存区域

​	本地方法栈、Java虚拟机栈、程序计数器、堆、元空间、直接内存

#### 	程序计数器

​	程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。这里面存的，就是当前线程执行的进度。

### 2、字符串常量位于哪个区域

​	字符串常量池，jdk8之前是perm区，jdk8及以后是在堆上面。
​	类文件常量池，是位于方法区，也就是元空间。

### 3、类加载的过程

​	加载
​	验证
​	准备（为一些类变量分配内存，并将其初始化为默认值）
​	解析（将符号引用替换为直接引用）
​    初始化

### 4、类加载器

​	Bootstrap ClassLoader（启动类加载器）
​	Extention ClassLoader（扩展类加载器）
​	App ClassLoader（应用类加载器）

### 5、双亲委派

双亲委派是可以被违背的吗？

​	可以。需要重写ClassLoader#loadClass和ClassLoader#findClass实现。

### 6、垃圾收集算法

​	标记清除（碎片化）
​	复制算法（浪费空间）
​	标记整理算法（效率比前两者差）
​	分代收集算法（老年代一般使用“标记-清除”、“标记-整理”算法，年轻代一般用复制算法）

#### (1)为什么年轻代用复制算法

​	因为年轻代存活的对象比较少，用复制算法只需要复制少量对象。

### 7、年轻代区域

​	默认比例 eden:from survivor:to survivor=8:1:1

#### (1)新创建的对象都是首先分配在年轻代吗？

​	不是的。新生代内存不够时，老年代分配担保。
​	大对象直接在老年代分配。

### 8、垃圾收集器

#### 	(1)年轻代

Serial垃圾收集器（单线程，通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。）
ParNew 垃圾收集器（多线程，追求降低用户停顿时间，适合交互式应用。）
Parallel Scavenge 垃圾收集器（追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。）

#### 	(2)老年代

Serial Old 垃圾收集器

Parallel Old垃圾收集器

CMS 垃圾收集器（以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。）

#### (3)客户端应用一般用哪个收集器

Serial 垃圾收集器（单线程，通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。）

#### (4)CMS垃圾收集器收集的过程？

CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：
初始标记
只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
并发标记
进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
重新标记
为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
并发清除
清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。

#### (5)G1垃圾收集器收集的过程？

Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：

1. 基于标记-整理算法，不产生内存碎片。

2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。

### 9、软引用和弱引用的区别

软引用一般用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，**只有在内存不足**时，系统则**会回收软引用对象**，如果回收了软引用对象之后仍然**没有足够的内存**，才会抛出**内存溢出异常**。

弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当**JVM进行垃圾回收**时，无论内存是否充足，**都会回收被弱引用关联的对象**

### 10、JVM怎么判断哪些对象需要删除哪些不用删除

根据GC Root进行查找标记